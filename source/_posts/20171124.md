---
title: React Native 网络层分析
date: 2017-11-23 
tags:
- React Native
- JavaScript
---

在使用`React Native`开发中，我们熟练的采用`JavaScript`的方式发送请求的方式发送一个请求到服务端，但是处理这个请求的过程其实和处理`Web`应用中发送的请求的过程是不一样的。因为处理这个请求的目标不是浏览器，而是嵌入这个应用的原生操作系统。

<!--more  -->
![banner](https://raw.githubusercontent.com/yandan66/yandan66.github.io/master/2017/11/23/20171124/xhr.jpeg)

在处理`React Native`的请求时，分为两部分：一部分是`JavaScript`的运行环境，另一部分是嵌入`JavaScript`的`Native`（即原生`Android`和`IOS`）运行环境。`React Native`内置了三种发送网络请求的方式：`fetch`, `XMLHttpRequest` 和 `WebSocket`。但是`React Native`的运行环境和Web应用的运行环境不一样，所以需要在原生应用层采用自定义函数来拓展运行时（runtime）环境来处理`JavaScript`发出的网络请求。

## 请求发送方式及过程
![banner](https://raw.githubusercontent.com/yandan66/yandan66.github.io/master/2017/11/23/20171124/network.jpeg)
对于常用的网络请求对象：XMLHttpRequest（XHR）、Fetch及WebSocket，熟悉前端开发的同学应该非常了解。`XHR`是Web开发中用得比较多的发送请求的方式，`Fetch`和`Websocket`也是后起之秀，在很多现代Web应用中得以采用。但是，在`React Native`中，这些对象的使用和Web应用是有差别的。当你在JS层调用网络请求时，其实是经历了两个过程才到达真正的服务器端。就像头部banner表示的那样。

#### XMLHttpRequest（XHR）
在`React Native`中, `XMLHttpRequest（XHR）`由两部分组成： “前端”（front-end）和“后端”（back-end）。前端负责与`JavaScript`交互，后端负责在原生平台上转换`JavaScript`发送过来的请求为原生系统自己的请求。

这里的后端其实是一个原生平台顶层抽象的统一API层，使得`JavaScript`层可以调用原先系统的网络模块。例如`IOS`下内置的[URLSession](https://developer.apple.com/documentation/foundation/urlsession)模块和`Android`下的[OKHTTP](http://square.github.io/okhttp/)模块。

#### Fetch
在现代Web浏览器中，`Fetch`API提供了和`XHR`大部分相同的功能，但是`Fetch`提供了一种更加简单，高效的方式来跨网络异步获取资源，同时可操纵`Request`和`Response`对象来复用请求。

但是在`React Native`中，为了兼容两种平台的差异，采用了依赖于`XMLHttpRequest`的[Fetch Polyfill](https://github.com/github/fetch)来实现这个请求对象。这就意味着我们不能像实用Web平台下的`Fetch`对象一样来实用`React Native`下的该对象。比如采用这个对象来发送binary数据。当然可以采用第三方的库比如[react-native-fetch-blob](https://github.com/wkh237/react-native-fetch-blob)来实现相应的功能。


#### Websocket
`Websocket`作为一种新的通信协议，采用全双工通讯方式与服务器间进行通信的网络技术。

在`React Native`中，`Websocket`并不是一个独立的请求，和`XMLHttpRequest（XHR）`一样由两部分组成： “前端”（front-end）和“后端”（back-end）。前端负责与`JavaScript`交互，后端负责在原生平台上转换`JavaScript`发送过来的请求为原生系统自己的请求。在IOS中采用的是自己开发的[NSStream](https://developer.apple.com/documentation/foundation/nsstream)，而在Android系统中则是[OKHTTP](http://square.github.io/okhttp/)模块。


## React Native发送二进制数据（binary data ）
由于`React Native`中`Fetch`对象的底层采用的是`XHR`实现，这就限制了发送二进制数据的功能。当然`React Native`提供了一系列的方式来解决这个问题，比如： 转换二进制文件为base64字符串或者采用第三方库[ react-native-fetch-blob](https://github.com/wkh237/react-native-fetch-blob)。但是并没有从底层解决这个问题。

#### 转换二进制为base64发送
到目前为止，`React Native`不能发送非序列化的数据，所以，要发送二进制数据，采用Base64编码的字符串是个不错的选择。
![banner](https://raw.githubusercontent.com/yandan66/yandan66.github.io/master/2017/11/23/20171124/base64.jpeg)

例如，你从服务器下载一张图片（注意：不是通过`url`从服务器获取），请求通过JavaScript线程，再通过`React Native`提供的桥接器，最后通过原生系统的网络模块发送到服务端。服务端返回一个Base64编码过的图片，`JavaScript`线程收到返回的字符串后，会分配相应的内存，然后`React Native`会调用相应的原生模块渲染成相应图片。但是值得主要的是，这种方式会造成典型的性能问题——内存泄漏。

通过Base64编码的方式传输二进制文件，这里会造成一系列性能问题，[这篇文章](https://medium.com/@talkol/performance-limitations-of-react-native-and-how-to-overcome-them-947630d7f440)中列出了大部分性能问题及提出了相应的解决方案。

现在使用的各种方法发送二进制文件都存在各种问题，最终的解决方式是要相应的标准能够实现二进制的传输。目前，`WebSocket`已经支持了二进制传输。在最新版本的`React Native`层也已经支持`WebSocket`协议来传输二进制文件，但是，相应的原生平台的网络模块暂时还不支持。


## 总结
`React Native`开发方式是非常不错的体验，但是，受各个平台差异和标准的限制，不得不折中处理一些问题。随之而来的是相应的性能、效率的问题。另外，采用开发，性能上和用户体验上和原生应用还是有一定差距。但是如果在原生应用中能够集成`React Native`，会显著提高开发效率。

## 参考
[Network layer in React Native](https://medium.com/dailyjs/network-layer-in-react-native-eec841f11861)
